#include "DataLogger.h"

DataLogger::DataLogger()
  : initialized_(false), raw_sample_count_(0), normalized_window_count_(0) {
}

DataLogger::~DataLogger() {
  close();
}

bool DataLogger::begin(const String& session_name) {
  if (initialized_) {
    return true;
  }

  // Generate filenames based on session name or timestamp
  if (session_name.length() > 0) {
    session_name_ = session_name;
  } else {
    session_name_ = String("data_") + String(millis());
  }

  String raw_filename = session_name_ + "_raw.bin";
  String normalized_filename = session_name_ + "_normalized.bin";
  String metadata_filename = session_name_ + "_metadata.txt";

  // Open raw data file (binary mode)
  if (!raw_file_.open(raw_filename.c_str(), O_WRONLY | O_CREAT | O_TRUNC)) {
    Serial.print("Failed to open raw data file: ");
    Serial.println(raw_filename);
    return false;
  }

  // Open normalized data file (binary mode)
  if (!normalized_file_.open(normalized_filename.c_str(), O_WRONLY | O_CREAT | O_TRUNC)) {
    Serial.print("Failed to open normalized data file: ");
    Serial.println(normalized_filename);
    raw_file_.close();
    return false;
  }

  // Open metadata file (text mode)
  if (!metadata_file_.open(metadata_filename.c_str(), O_WRONLY | O_CREAT | O_TRUNC)) {
    Serial.print("Failed to open metadata file: ");
    Serial.println(metadata_filename);
    raw_file_.close();
    normalized_file_.close();
    return false;
  }

  initialized_ = true;
  raw_sample_count_ = 0;
  normalized_window_count_ = 0;

  Serial.println("DataLogger initialized:");
  Serial.print("  Raw: ");
  Serial.println(raw_filename);
  Serial.print("  Normalized: ");
  Serial.println(normalized_filename);
  Serial.print("  Metadata: ");
  Serial.println(metadata_filename);

  writeMetadata();

  return true;
}

void DataLogger::logRawSample(float sample) {
  if (!initialized_ || !raw_file_.isOpen()) {
    return;
  }

  // Write as 32-bit float (4 bytes)
  raw_file_.write((const uint8_t*)&sample, sizeof(float));
  raw_sample_count_++;

  // Flush every 1000 samples to avoid data loss
  if (raw_sample_count_ % 1000 == 0) {
    raw_file_.sync();
  }
}

void DataLogger::logNormalizedWindow(const float* window, int size, int epoch_index) {
  if (!initialized_ || !normalized_file_.isOpen() || !window) {
    return;
  }

  // Write epoch index first (4 bytes int)
  normalized_file_.write((const uint8_t*)&epoch_index, sizeof(int));

  // Write window size (4 bytes int)
  normalized_file_.write((const uint8_t*)&size, sizeof(int));

  // Write all samples as 32-bit floats
  normalized_file_.write((const uint8_t*)window, size * sizeof(float));

  normalized_window_count_++;

  // Flush after each window to ensure data is saved
  normalized_file_.sync();

  // Log progress every 10 windows
  if (normalized_window_count_ % 10 == 0) {
    Serial.print("DataLogger: ");
    Serial.print(normalized_window_count_);
    Serial.print(" windows logged, ");
    Serial.print(raw_sample_count_);
    Serial.println(" raw samples");
  }
}

void DataLogger::flush() {
  if (raw_file_.isOpen()) {
    raw_file_.sync();
  }
  if (normalized_file_.isOpen()) {
    normalized_file_.sync();
  }
}

void DataLogger::close() {
  if (raw_file_.isOpen()) {
    raw_file_.sync();
    raw_file_.close();
  }
  if (normalized_file_.isOpen()) {
    normalized_file_.sync();
    normalized_file_.close();
  }
  if (metadata_file_.isOpen()) {
    // Update final counts in metadata
    metadata_file_.rewind();
    writeMetadata();
    metadata_file_.sync();
    metadata_file_.close();
  }

  if (initialized_) {
    Serial.println("DataLogger closed:");
    Serial.print("  Total raw samples: ");
    Serial.println(raw_sample_count_);
    Serial.print("  Total normalized windows: ");
    Serial.println(normalized_window_count_);
  }

  initialized_ = false;
}

void DataLogger::writeMetadata() {
  if (!metadata_file_.isOpen()) {
    return;
  }

  metadata_file_.rewind();

  // Write metadata in human-readable format
  metadata_file_.println("# EEG Data Logger Metadata");
  metadata_file_.println("# Generated by Sleep Headband Firmware");
  metadata_file_.println();

  metadata_file_.print("session_name: ");
  metadata_file_.println(session_name_);

  metadata_file_.print("timestamp_ms: ");
  metadata_file_.println(millis());

  metadata_file_.println();
  metadata_file_.println("# Raw Data File Format:");
  metadata_file_.println("# - Binary file containing float32 samples");
  metadata_file_.println("# - Each sample: 4 bytes (32-bit float)");
  metadata_file_.println("# - Sample order: sequential filtered bipolar EEG samples");
  metadata_file_.println("# - Sample rate: 100 Hz");
  metadata_file_.print("raw_sample_count: ");
  metadata_file_.println(raw_sample_count_);

  metadata_file_.println();
  metadata_file_.println("# Normalized Data File Format:");
  metadata_file_.println("# - Binary file containing normalized windows");
  metadata_file_.println("# - Each window structure:");
  metadata_file_.println("#   - epoch_index: 4 bytes (int32)");
  metadata_file_.println("#   - window_size: 4 bytes (int32)");
  metadata_file_.println("#   - samples: window_size * 4 bytes (float32 array)");
  metadata_file_.println("# - Samples are z-score normalized (mean=0, std=1)");
  metadata_file_.println("# - Window size: 3000 samples (30 seconds at 100Hz)");
  metadata_file_.print("normalized_window_count: ");
  metadata_file_.println(normalized_window_count_);

  metadata_file_.println();
  metadata_file_.println("# Processing Pipeline:");
  metadata_file_.println("# 1. Raw EEG channels read from SD card");
  metadata_file_.println("# 2. Bipolar derivation calculated (Ch+ - Ch-)");
  metadata_file_.println("# 3. Bandpass filter applied (0.5-35 Hz)");
  metadata_file_.println("# 4. Z-score normalization per window");
  metadata_file_.println("# 5. Model inference on normalized window + epoch index");

  metadata_file_.sync();
}
